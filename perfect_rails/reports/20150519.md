概要
---

+ 場所
 + 1F
+ タイムテーブル
 + 準備(5分)
 + グループディスカッション(35分)
 + 次の回の範囲決め(5分)
+ ファシリテーター
 + @o-sawa
+ レポーター
 + @ssusan

範囲
---

+ 9-1 アーキテクチャパターンから見るRails (p332-333)﻿
+ 9-2 複雑なバリデーションとコールバックを整理する (p334-342)﻿

グループ分け(敬称略)
---

+ @val00274 @aisaka @n-imai @ssusan @TMogi @o-sawa

共有内容
---

- 9章突入
- 「ActiveRecordの落とし穴とそれを回避する方法」
- 今回の内容が必要な状況に出会ったことが無いので実感がわかない問題
- AテーブルとBテーブルのそれぞれの値をまとめて扱う場合はどうする？
    - どちらかのクラスの持ち物にしちゃうか、中間のActiveModelで持つか
- Validatorを共有する場面は想像できるけど、それがいいのか判断が難しい
    - なんでもかんでも共通化は怖い
    - 積極的に共有すべきか、むしろすべきでないのか
    - 単純につらつらと書かれている処理の独立に価値がある？
- EachValidator
    - Validatorのサブクラス
    - 1つの属性値を検証するのに特化したValidatorの一種
    - `validates :email, presence: true, email: true`
        - 最初の`:email`はフィールド名
        - このフィールドに対し、`PresenceValidator`と`EmailValidator`で判定するという意味になる
- paranoia gem
    - 音ゲーか
- `ActiveRecord::Validations`以下のValidatorクラスの継承
    - `UniquenessValidator`の例では`validate_each`メソッドの内容をほとんどコピーしてるらしい
    - 継承を使わずに既存のValidatorの機能を使う手はない？
    - 普通はコンポジションでは？
    - そりゃできるでしょうよ感もありつつ、他にもインスタンスメソッドはあるのでこの関数限定の方が良いか
- まとめ
    - 便利だね
    - 危険なところはいじらない

次回
---
+ 第34回 5月26日
+ 内容
  + 9-3 DBに依存しないモデルを作るActiveModel p.343-353
+ 担当
  + ファシリ : @val00274 さん
  + レポータ : @n-imai さん
